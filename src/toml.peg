{
  var nodes = [];

  function node(line, column, type, value, key) {
    var node = { type: type, value: value, line: line, column: column };
    if (key) node.key = key;
    nodes.push(node);
    return node;
  };
}

start
  = line*                               { return nodes }

line
  = S* expr:expression S* comment* (NL+ / EOF)
  / S+ (NL+ / EOF)

expression
  = comment / subpath / assignment

comment
  = '#' (!(NL / EOF) .)*

subpath
  = '[' name:key ']'                    { return node(line, column, 'Group', name) }

assignment
  = key:key S* '=' S* value:value       { return node(line, column, 'Set', value, key) }

key
  = chars:(!S !NL !'[' !']' !'=' char:. { return char })+ { return chars.join('') }

value
  = string / datetime / float / integer / boolean / array

string
  = '"' chars:string_char* '"'          { return node(line, column, 'String', chars.join('')) }

string_char
  = ESCAPED / (!'"' !'\\' char:. { return char })

float
  =     digits:(DIGITS '.' DIGITS)      { return node(line, column, 'Float',      parseFloat(digits.join(''))) }
  / '-' digits:(DIGITS '.' DIGITS)      { return node(line, column, 'Float', -1 * parseFloat(digits.join(''))) }

integer
  =     digits:DIGIT+ !'.'              { return node(line, column, 'Integer',      parseInt(digits.join(''), 10)) }
  / '-' digits:DIGIT+ !'.'              { return node(line, column, 'Integer', -1 * parseInt(digits.join(''), 10)) }

boolean
  = 'true'                              { return node(line, column, 'Boolean', true)  }
  / 'false'                             { return node(line, column, 'Boolean', false) }

array
  = '[' value:array_value? ']'                         { return node(line, column, 'Array', value ? [value] : []) }
  / '[' values:array_value_list+ ']'                   { return node(line, column, 'Array', values) }
  / '[' values:array_value_list+ value:array_value ']' { return node(line, column, 'Array', values.concat(value)) }

array_value
  = SS* value:value SS*                 { return value }

array_value_list
  = SS * value:value SS* ',' SS*        { return value }

datetime
  = date:(
      DIGIT DIGIT DIGIT DIGIT
      '-'
      DIGIT DIGIT
      '-'
      DIGIT DIGIT
      'T'
      DIGIT DIGIT
      ':'
      DIGIT DIGIT
      ':'
      DIGIT DIGIT
      'Z'
    )            { return node(line, column, 'Datetime', new Date(date.join(''))) }

S                = [ \t]
SS               = [ \t] / NL / comment
NL               = "\n" / "\r" "\n"
EOF              = !.
HEX              = [0-9a-f]i
DIGIT            = [0-9]
DIGITS           = d:[0-9]+             { return d.join('') }
ESCAPED          = '\\"'                { return '"'  }
                 / '\\\\'               { return '\\' }
                 / '\\/'                { return '/'  }
                 / '\\b'                { return '\b' }
                 / '\\t'                { return '\t' }
                 / '\\n'                { return '\n' }
                 / '\\f'                { return '\f' }
                 / '\\r'                { return '\r' }
                 / ESCAPED_UNICODE
ESCAPED_UNICODE  = "\\u" digits:(HEX HEX HEX HEX) { return String.fromCharCode(parseInt("0x" + digits.join(''))) }
